/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package one.dedic.jmri.decodernext.validation.support;

import com.jgoodies.validation.ValidationResult;
import java.awt.Component;
import java.util.ArrayList;
import java.util.List;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import one.dedic.jmri.decodernext.validation.ContextValidator;
import one.dedic.jmri.decodernext.validation.ValidatorService;
import org.openide.util.Lookup;

/**
 * Groups validator services under one umbrella one. The service forwards
 * any ChangeEvents generated by the contained Validators. In addition, it 
 * generates a ChangeEvent whenever a Validator is added or removed.
 * @author sdedic
 */
public class ValidatorGroup implements ValidatorService, ContextValidator {
    private final ValidatorService owner;
    private final List<ChangeListener> listeners = new ArrayList<>();
    private final List<ValidatorService>  validators = new ArrayList<>();
    private final ChangeListener valL = this::fireChange;
    
    private Lookup context = Lookup.EMPTY;
    private volatile ValidationResult lastResult = ValidationResult.EMPTY;
    private boolean active;

    public ValidatorGroup(ValidatorService owner) {
        this.owner = owner;
    }
    
    public ValidatorGroup() {
        owner = this;
    }

    @Override
    public void attach(Lookup context) {
        this.context = context;
        
        List<ValidatorService> vv;
        synchronized (this) {
            if (validators.isEmpty()) {
                return;
            }
            vv = new ArrayList<>(validators);
        }
        vv.forEach((v) -> {
            if (v instanceof ContextValidator) {
                ((ContextValidator)v).attach(context);
            }
        });
    }
    
    public Lookup getLookup() {
        return context;
    }
    
    @Override
    public void addChangeListener(ChangeListener l) {
        synchronized (this) {
            listeners.add(l);
        }
    }

    @Override
    public void removeChangeListener(ChangeListener l) {
        synchronized (this) {
            listeners.remove(l);
        }
    }
    
    private void fireChange(ChangeEvent e) {
        doInEDT(this::doFireChange);
    }
    
    private void fireChange() {
        if (lockCount != 0) {
            return;
        }
        doInEDT(this::doFireChange);
    }
    
    private void doFireChange() {
        ChangeListener[] ll;
        
        synchronized (this) {
            if (listeners.isEmpty()) {
                return;
            }
            ll = listeners.toArray(new ChangeListener[listeners.size()]);
        }
        ChangeEvent e = new ChangeEvent(owner);
        for (ChangeListener l : ll) {
            l.stateChanged(e);
        }
    }

    @Override
    public ValidationResult getValidation() {
        return lastResult;
    }

    @Override
    public ValidationResult validate() {
        assert SwingUtilities.isEventDispatchThread();
        ValidationResult compound = new ValidationResult();
        
        for (ValidatorService srv : validators) {
            compound.addAllFrom(srv.validate());
        }
        
        this.lastResult = ValidationResult.unmodifiableResult(compound);
        return compound;
    }

    @Override
    public Component findComponent(Object key) {
        return null;
    }

    @Override
    public void addNotify() {
        if (active) {
            return;
        }
        List<ValidatorService> vv;
        synchronized (this) {
            vv = new ArrayList<>(validators);
            active = true;
        }
        vv.forEach((v) -> v.addNotify());
    }

    @Override
    public void removeNotify() {
        if (!active) {
            return;
        }
        List<ValidatorService> vv;
        synchronized (this) {
            vv = new ArrayList<>(validators);
            active = false;
        }
        vv.forEach((v) -> v.removeNotify());
    }
    
    private void doInEDT(Runnable r) {
        if (SwingUtilities.isEventDispatchThread()) {
            r.run();
        } else {
            SwingUtilities.invokeLater(r);
        }
    }
    
    private void attached(boolean a, ValidatorService srv) {
        if (srv instanceof ContextValidator) {
            ((ContextValidator)srv).attach(context);
        }
        srv.addChangeListener(valL);
        if (a) {
            srv.addNotify();
        }
    }

    private void dettached(ValidatorService srv) {
        srv.removeChangeListener(valL);
        srv.removeNotify();
    }
    
    public void addValidator(ValidatorService srv) {
        boolean a;
        boolean l;
        synchronized (this) {
            if (validators.contains(srv)) {
                return;
            }
            validators.add(srv);
            l = lockCount == 0;
            changed = true;
            a = active;
        }
        doInEDT(() -> attached(a, srv));
        if (a) {
            if (l) fireChange();
        }
    }
    
    public void removeValidator(ValidatorService srv) {
        if (srv == null) {
            return;
        }
        boolean a;
        boolean l;
        synchronized (this) {
            if (!validators.contains(srv)) {
                return;
            }
            validators.remove(srv);
            l = lockCount == 0;
            changed = true;
            a = active;
        }
        if (a) {
            doInEDT(() -> dettached(srv));
            if (l) fireChange();
        }
    }
    
    private volatile boolean changed;
    private volatile int lockCount;
    
    protected boolean runAtomic(Runnable r) {
        boolean c = false;
        try {
            synchronized (this) {
                lockCount++;
            }
            r.run();
        } finally {
            int cnt;
            
            synchronized (this) {
                cnt = --lockCount;
            }
            if (cnt == 0) {
                if (changed) {
                    changed = false;
                    c = true;
                    fireChange();
                }
            }
        }
        return c;
    }
}
